import numpy as np
import core as cfc
import matplotlib.pyplot as plt


# Class used for calculating basic properties for a beam.
class Beam:
    def __init__(self, forces=[], supports=[], loads=[],
                 E=2.1e11, A=45.3e-4, I=2510e-8):
        # self.forces = [[3*f[1]+2 for f in forces],[f[2] for f in forces]]
        self.forces = forces
        self.loads = loads
        self.bc = self.get_boundary_conditions(supports)
        self.ep = np.array([E, A, I])
        self.ey = np.array([0., 0.])
        self.ex = np.array([0., 1/11])
        self.loadsplitter = 8
        self.loadsplittan = (self.loadsplitter-1)*3
        self.beam_parts, self.load_coords = self.split_beam(forces, supports, loads)
        self.nel = 11 + sum([l[1][1] - l[1][0] for l in loads]) * (self.loadsplitter-1)  # Turning all the loaded elements into 8 elements
        self.nparts = len(self.beam_parts)
        self.load_index = [i for i, part in enumerate(self.beam_parts) if
                           part[0] in self.load_coords[0] or part[1] in self.load_coords[1]]
        #K, f = self.get_stiffnes_matrix()
        print(self.beam_parts)
        print(self.load_index)

    def split_beam(self, forces, supports, loads):
        force_coords = [f[1] for f in forces]
        support_coords = [s[1] for s in supports]
        load = [l[1] for l in loads]
        load_coords = [[start for start, stop in load],
                       [stop for start, stop in load],
                       [l[2] for l in loads]]
        split_coords = force_coords
        split_coords.extend(support_coords)
        split_coords.extend([0, 11])
        split_coords.extend(load_coords[0])
        split_coords.extend(load_coords[1])
        split_coords = list(set(split_coords))
        beam_parts = [[split_coords[i], split_coords[i + 1]] for i in range(len(split_coords) - 1)]
        return (beam_parts, load_coords)

    def get_part_len(self, part):
        return part[1] - part[0]

    def get_edof(self):
        Edof = []
        for i in range(self.nel):
            Edof.append([3 * i + 1, 3 * i + 2, 3 * i + 3, 3 * i + 4, 3 * i + 5, 3 * i + 6])
        Edof = np.asarray(Edof)
        return Edof

    def get_stiffnes_matrix(self):
        # Check if load or not
        Edof = self.get_edof()
        K = np.mat(np.zeros((Edof[-1][-1], Edof[-1][-1])))
        f = np.mat(np.zeros((Edof[-1][-1], 1)))

        loads = [l[1] for l in self.loads]
        for fo in self.forces:
            c = 0
            for l in loads:

                if fo[1] > l[1]:
                    c += l[1] - l[0]

            if fo[0] == 'Force':
                f[c * self.loadsplittan + 3 * fo[1] + 1] = fo[2]

            elif fo[0] == 'Moment':
                f[c * self.loadsplittan + 3 * fo[1] + 2] = fo[2]

        j = 0
        load_len = 0
        for i, p in enumerate(self.beam_parts):
            if i in self.load_index:
                load_len += self.load_coords[1][j] - self.load_coords[0][j]
                ex = self.ex / self.loadsplitter
                eq = [0, self.loads[j][2]]
                Ke, fe = cfc.beam2e(ex, self.ey, self.ep, eq)
                K, f = cfc.assem(
                    Edof[p[0] + (load_len - self.load_coords[1][j] + self.load_coords[0][j]) * (self.loadsplitter-1):p[1] + load_len * (self.loadsplitter-1)],
                    K, Ke, f, fe)
                # print([p[0]+(load_len-self.load_coords[1][j]+self.load_coords[0][j])*7,p[1]+load_len*7])
                j += 1
            else:
                ex = self.ex
                Ke = cfc.beam2e(ex, self.ey, self.ep)
                K = cfc.assem(Edof[p[0] + load_len * (self.loadsplitter-1):p[1] + load_len * (self.loadsplitter-1)], K, Ke)
                # print([p[0]+load_len*7,p[1]+load_len*7])
        #print('f = ', f)
        return K, f

    def get_boundary_conditions(self, supports):
        loads = [l[1] for l in self.loads]
        bc = []

        for s in supports:
            c = 0
            for l in loads:
                if s[1] >= l[1]:
                    c += l[1] - l[0]
                elif s[1] >= l[0]:
                    c += s[1] - l[0]

            if s[0] == 'RollerSupport':
                bc.extend([c * (7*3) + 3 * s[1] + 2])   # 21 borde egentligen vara self.loadsplitter-1 * 3 men vill inte fungera lol

            if s[0] == 'PinSupport':
                bc.extend([c * 21 + 3 * s[1] + 1, c * 21 + 3 * s[1] + 2])

            if s[0] == 'Surface':
                bc.extend([c * 21 + 3 * s[1] + 1, c * 21 + 3 * s[1] + 2, c * 21 + 3 * s[1] + 3])

        print('bc =', bc)
        return bc

    def get_solutions(self):
        K, f = self.get_stiffnes_matrix()
        (a, r) = cfc.solveq(K, f, np.array(self.bc))
        return a, r

    def get_coordinates(self):
        coord = []
        for i, p in enumerate(self.beam_parts):
            if i in self.load_index:
                for c in range(p[0], p[1]):
                    for j in range(self.loadsplitter):
                        coord.extend([c + j / self.loadsplitter])
            else:
                for c in range(p[0], p[1]):
                    coord.append(c)
        coord.append(11)
        print(coord)
        return coord

    def get_section_forces(self, p, i, eq=None):
        Edof = self.get_edof()
        a, r = self.get_solutions()
        ed = cfc.extractEldisp(Edof, a)
        #print(ed)

        if not eq is None:
            start = np.asarray(cfc.beam2s(self.ex, self.ey, self.ep, ed[i - 1, :], eq=eq)[0][0])[0]
            end = np.asarray(cfc.beam2s(self.ex, self.ey, self.ep, ed[i - 1, :], eq=eq)[0][1])[0]

        else:
            start = np.asarray(cfc.beam2s(self.ex, self.ey, self.ep, ed[i - 1, :], eq=eq)[0][0])[0]
            end = np.asarray(cfc.beam2s(self.ex, self.ey, self.ep, ed[i - 1, :], eq=eq)[0][1])[0]

        # start = np.asarray(cfc.beam2s(self.ex,self.ey,self.ep,ed[i+c])[0])[0]
        # end = np.asarray(cfc.beam2s(self.ex,self.ey,self.ep,ed[i+c])[0])[1]
        #print(start, 'start')
        #print(end, 'end')

        return start, end

    def get_shear_diagram(self):
        coord = self.get_coordinates()
        Val = []
        c = 0
        j = 0
        for i, p in enumerate(self.beam_parts):
            if i in self.load_index:
                j += 1
                eq = [0, self.loads[i][2]]
                for _ in range((p[1] - p[0]) * self.loadsplitter):
                    c += 1
                    # print(c)
                    Val.append(self.get_section_forces(p, c, eq=eq)[0][1])
                    # print(self.get_section_forces(p,c,eq=eq)[0][1])
            else:
                for _ in range(p[1] - p[0]):
                    c += 1
                    # print(c)
                    Val.append(self.get_section_forces(p, c, eq=None)[0][1])
        Val.append(self.get_section_forces(p, c, eq=None)[1][1])
        print(Val)
        # print(coord)
        plt.grid()
        plt.plot(coord, -np.asarray(Val))
        plt.show()



inputJim = {'Beam0': [('Force', 11, 1), ('Load', (0, 3), -3), ('PinSupport', 0), ('RollerSupport', 7)]}
inputJocke = {'Beam0': [('Force', 3, -0.2), ('Force', 6, -0.1), ('Force', 9, -0.15), ('Moment', 0, -0.05), ('Surface', 11)]}

balkar = list(inputJim.keys())
balk3 = inputJim[balkar[0]]

def get_forces(balk):
    return sorted([b for b in balk if b[0] in ['Force', 'Moment']], key=lambda tup: tup[1])

def get_supports(balk):
    return sorted([b for b in balk if b[0] in ['PinSupport', 'RollerSupport', 'Surface']], key=lambda tup: tup[1])

def get_loads(balk):
    return sorted([b for b in balk if b[0] in ['Load']], key=lambda tup: tup[1][0])

print(get_forces(balk3))
print(get_supports(balk3))
print(get_loads(balk3))

balken = Beam(get_forces(balk3), get_supports(balk3), get_loads(balk3))


print(balken.load_index)
balken.get_coordinates()
print(balken.beam_parts, 'beam parts ')
balken.get_shear_diagram()

#balken.get_stiffnes_matrix()


